"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

BLOCKSIZE = 65536
TEMPLATES = {  }
FILE_SHAS = {  }
def try_int(value):
    ...

def ensure_host_list(hosts, inventory):
    ...

def memoize(func):
    ...

def get_caller_frameinfo(frame_offset=...):
    ...

def extract_callable_datas(datas):
    ...

class FallbackDict(object):
    '''
    Combines multiple AttrData's to search for attributes.
    '''
    override_datas = ...
    def __init__(self, *datas):
        ...
    
    def __getattr__(self, key):
        ...
    
    def __setattr__(self, key, value):
        ...
    
    def __str__(self):
        ...
    
    def dict(self):
        ...
    


@memoize
def show_stdin_global_warning():
    ...

def pop_global_op_kwargs(state, kwargs):
    '''
    Pop and return operation global keyword arguments.
    '''
    ...

def unroll_generators(generator):
    '''
    Take a generator and unroll any sub-generators recursively. This is
    essentially a Python 2 way of doing `yield from` in Python 3 (given
    iterating the entire thing).
    '''
    ...

def get_template(filename_or_string, is_string: bool = ...):
    '''
    Gets a jinja2 ``Template`` object for the input filename or string, with caching
    based on the filename of the template, or the SHA1 of the input string.
    '''
    ...

def underscore(name):
    '''
    Transform CamelCase -> snake_case.
    '''
    ...

def sha1_hash(string):
    '''
    Return the SHA1 of the input string.
    '''
    ...

def format_exception(e):
    ...

def log_host_command_error(host, e, timeout=...):
    ...

def get_arg_value(state, host, arg):
    '''
    Runs string arguments through the jinja2 templating system with a state and
    host. Used to avoid string formatting in deploy operations which result in
    one operation per host/variable. By parsing the commands after we generate
    the ``op_hash``, multiple command variations can fall under one op.
    '''
    ...

def make_hash(obj):
    '''
    Make a hash from an arbitrary nested dictionary, list, tuple or set, used to generate
    ID's for operations based on their name & arguments.
    '''
    ...

class get_file_io(object):
    '''
    Given either a filename or an existing IO object, this context processor
    will open and close filenames, and leave IO objects alone.
    '''
    close = ...
    def __init__(self, filename_or_io, mode=...):
        self.filename_or_io = ...
        self.mode = ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, type, value, traceback):
        ...
    
    @property
    def cache_key(self):
        ...
    


def get_file_sha1(filename_or_io):
    '''
    Calculates the SHA1 of a file or file object using a buffer to handle larger files.
    '''
    ...

def read_buffer(type_, io, output_queue, print_output: bool = ..., print_func: Optional[Any] = ...):
    '''
    Reads a file-like buffer object into lines and optionally prints the output.
    '''
    ...

